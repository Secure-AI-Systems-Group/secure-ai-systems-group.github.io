<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <!-- Title -->
        <title>
            CS 578 :: Sp25 :: Cyber-Security
        </title>

        <!-- SEO -->
        <meta name="author" content="Sanghyun Hong">
        <meta name="description" content="Trustworthy Machine Learning Oregon State University">
        <meta name="keywords" content="sanghyun hong albert Trustworthy Machine Learning oregon state university">

        <!-- Favicon -->
        <link rel="shortcut icon" href="/resources/favicon.ico" type="image/x-icon">

        <!-- Prevent js cache by Chrome -->
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
        <meta http-equiv="Pragma" content="no-cache" />
        <meta http-equiv="Expires" content="0" />

        <!-- Bootstrap start -->
        <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Arial:300,400,500,700" />
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

        <!-- CSS -->
        <link rel="stylesheet" type="text/css" href="/css/osu-fonts.css">
        <link rel="stylesheet" type="text/css" href="/css/osu-styles.css">

    </head>
    <body>

        <!-- Content -->
        <div class="container">

            <!-- Title -->
            <h2 class="title">
                <b>CS 578 :: Spring 2025 :: Cyber-Security</b>
            </h2>

            <hr noshade="" size="1">

            <!-- Top navigation bar -->
            <ul class="nav">
                <li class="nav-item">
                    <a class="nav-link" href="index.html"><h5>Home</h5></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="syllabus.html"><h5>Syllabus</h5></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="critiques.html"><h5>Critique, Presentation</h5></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link active" aria-current="page" href="homework.html"><h5>Homework</h5></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="project.html"><h5>Project</h5></a>
                </li>
            </ul>

            <hr noshade="" size="1">

            
            <!-- Homeworks -->
            <div class="accordion" id="homeworkExample">


                <!-- HW1 -->
                <div class="card">
                    <div class="card-header" id="headingOne">
                        <button class="btn btn-link" 
                            type="button" 
                            style="color: black;"
                            data-toggle="collapse" 
                            data-target="#homework1" 
                            aria-expanded="false" 
                            aria-controls="homework1">
                            <h4>Homework 1: Your Packets Are Mine</h4>
                        </button>
                    </div>
              
                    <div id="homework1" 
                         class="collapse" 
                         aria-labelledby="headingOne"
                         data-parent="#homeworkExample">
                        <div class="card-body">

                            <!-- :: Deadlines -->
                            <h5>Important Dates</h5>
                            <ul>
                                <li><b style="color: #D73F09;">Out: 04.02.2025 09:00 AM PT</b></li>
                                <li><b style="color: #D73F09;">Due: 04.16.2025 11:59 PM PT</b></li>
                            </ul>


                            <!-- :: Introduction -->
                            <h5 style="margin-top: 20px;">Homework Overview</h5>
                            <p>
                                The learning objective of this homework is for you to understand the basics of network traffic and packet analysis. You will be required to capture <code>DNS</code> and <code>HTTP/HTTPS</code> packets using <a href="https://www.wireshark.org/" target="_blank">Wireshark</a> and analyze them.
                            </p>


                            <!-- :: Setup -->
                            <h5 style="margin-top: 20px;">Initial Setup</h5>
                            <p>
                                To begin with, you are required to install Wireshark. You need to have access to a computer that support both Wireshark and the <code>libpcap</code> library. Wireshark is available for Windows, macOS, and Linux. You can download the latest version from the official website [<a href="https://www.wireshark.org/download.html" target="_blank">link</a>]. Your operating system (OS) may have the libpcap software installed. If you face an issue with the libpcap library, you can install it as follows, depending on your OS:<br/>
                                <ul>
                                    <li>
                                        <b>Windows</b>: You can install <code>WinPcap</code> or <code>Npcap</code> [<a href="https://www.wireshark.org/download.html" target="_blank">link</a>].
                                    </li>
                                    <li>
                                        <b>Linux or MacOS</b>: You can install libpcap. [<a href="https://www.tcpdump.org/" target="_blank">link</a>].
                                    </li>
                                </ul>
                            </p>


                            <!-- :: Sample Run -->
                            <p>
                                <h5 style="margin-top: 20px;">Running Wireshark</h5>

                                When you run the Wireshark program, the Wireshark GUI shown in <a href="resources/main_wireshark.png" target="_blank">this figure (on Mac)</a> will be displayed. Initially, you can see the list of network interfaces on your computer, and a time-series diagram of the packets coming in and going out from the interface will be shown.<br/><br/>

                                Now you are ready to do a test drive!<br/>
                                <ul>
                                    <li>
                                        <b>Step 1:</b> Start Wireshark and select the network interface (e.g., eth0) you want to capture packets from. You can do this by clicking on the <code>Capture</code> menu and selecting <code>Options</code>.
                                    </li>
                                    <li>
                                        <b>Step 2:</b> Click on the <code>Start</code> button to begin capturing packets. You should see packets being displayed in the packet-listing window.
                                    </li>
                                    <li>
                                        <b>Step 3:</b> To filter the captured packets, enter a protocol name or other criteria in the packet-display filter field. For example, you can enter <code>http</code> to display only HTTP packets, as shown in <a href="resources/capture_wireshark.png" target="_blank">this figure</a>.
                                    </li>
                                    <li>
                                        <b>Step 4:</b> To stop capturing packets, click on the <code>Capture</code> menu and select <code>Stop</code>. You can also click on the <span style="color: #D73F09;">red square button</span> in the toolbar.
                                    </li>
                                    <li>
                                        <b>Step 5:</b> To save the captured packets, click on the <code>File</code> menu and select <code>Save As</code>. Choose a location and file name to save the captured packets.
                                    </li>
                                    <li>
                                        <b>Step 6:</b> To analyze the captured packets, select a packet in the packet-listing window. The details of the selected packet will be displayed in the packet-header details window and the packet-contents window.
                                    </li>
                                    <li>
                                        <b>Step 7:</b> You can expand or minimize the details of the packet by clicking on the arrowhead to the left of the protocol name in the packet-header details window. This will show you more information about the packet, such as the source and destination IP addresses, port numbers, and protocol-specific information.
                                    </li>
                                </ul>

                            </p>


                            <!-- :: Task I -->
                            <h5 style="margin-top: 20px;">Task I: Trace DNS with Wireshark</h5>

                            Capture the DNS packets generated by ordinary Web-surfing activity. You will need to analyze the captured packets and answer the following questions:<br/><br/>

                            <ul>
                                <li><b>Step 1:</b>
                                    Use <code>ipconfig</code> (Windows) / <code>ifconfig</code> (Linux, Mac) to empty the DNS cache on your host.
                                </li>
                                <li><b>Step 2:</b>
                                    Open your browser and clear your browser cache. (For Internet Explorer, go to the Tools menu, select Internet Options, then in the General tab select Delete Files.)
                                </li>
                                <li><b>Step 3:</b>
                                    Open Wireshark and enter <code>ip.addr == your_IP_address</code> into the filter, where you obtain your IP address (the IP address for the computer running Wireshark) with <code>ipconfig</code>. This filter removes all packets that neither originate nor are destined for your host.
                                </li>
                                <li><b>Step 4:</b>
                                    Start packet capture in Wireshark.
                                </li>
                                <li><b>Step 5:</b>
                                    With your browser, visit the Web page: <a href="https://www.google.com" target="_blank">https://www.google.com</a>.
                                </li>
                                <li><b>Step 6:</b>
                                    Stop packet capture.
                                </li>
                            </ul>

                            Now answer the following questions:<br/><br/>

                            <ol>
                                <li>What is the IP address of your computer?</li>
                                <li>What is the IP address of the Google web server?</li>
                                <li>How many DNS queries were generated by your web browser?</li>
                                <li>How many DNS responses were received by your web browser?</li>
                                <li>What is the port number used by your web browser to send the DNS query to the DNS server?</li>
                                <li>What is the size of the DNS query packet sent from your web browser to the DNS server?</li>
                                <li>What is the size of the DNS response packet sent from the DNS server to your browser?</li>
                            </ol>

                            
                            <!-- :: Task II -->
                            <h5 style="margin-top: 20px;">Task II: HTTP and HTTPs Protocols</h5>

                            Now we use Wireshark to capture HTTP and HTTPS packets. You will need to analyze the captured packets and answer the following questions:<br/><br/>

                            <ul>
                                <li><b>Step 1:</b>
                                    Use <code>ipconfig</code> (Windows) / <code>ifconfig</code> (Linux, Mac) to empty the DNS cache on your host.
                                </li>
                                <li><b>Step 2:</b>
                                    Open your browser and clear your browser cache. (For Internet Explorer, go to the Tools menu, select Internet Options, then in the General tab select Delete Files.)
                                </li>
                                <li><b>Step 3</b>
                                    Open Wireshark and enter <code>ip.addr == your_IP_address</code> into the filter, where you obtain your IP address (the IP address for the computer running Wireshark) with <code>ipconfig</code>. This filter removes all packets that neither originate nor are destined for your host.
                                </li>
                                <li><b>Step 4:</b>
                                    Start packet capture in Wireshark.
                                </li>
                                <li><b>Step 5:</b>
                                    With your browser, visit the website: <a href="http://relaxedgoodglowingmagic.neverssl.com/online/" target="_blank">http://relaxedgoodglowingmagic.neverssl.com/online/</a>.
                                </li>
                                <li><b>Step 6:</b>
                                    Stop packet capture.</li>
                                <li><b>Step 7:</b>
                                    Repeat Step 4-6 with the website: <a href="https://relaxedgoodglowingmagic.neverssl.com/online/" target="_blank">https://relaxedgoodglowingmagic.neverssl.com/online/</a>.
                                </li>
                            </ul>

                            Now answer the following questions:<br/><br/>

                            
                            <ul>
                                <li><b>HTTP website:</b></li>
                                <ol>
                                    <li>What is the IP address of your computer?</li>
                                    <li>What is the IP address of the <code>HTTP</code> website?</li>
                                    <li>What version of HTTP is the website running?</li>
                                    <li>What is the status code returned from the website to your browser?</li>
                                    <li>What is the port number used by your browser to send the HTTP request to your web browser?</li>
                                    <li>What is the port number used by the HTTP website to send the HTTP response to your web browser?</li>
                                    <li>What is the size of the data in the HTTP response packet sent from the HTTP website to your browser?</li>
                                </ol><br/>


                                <li><b>HTTPS website:</b></li>
                                <ol>
                                    <li>What is the IP address of your computer?</li>
                                    <li>What is the IP address of the <code>HTTPS</code> website?</li>
                                    <li>What version of TLS is the website running?</li>
                                    <li>What is the status code returned from the website to your browser?</li>
                                    <li>What is the port number used by your browser to send the HTTPS request to your web browser?</li>
                                    <li>What is the port number used by the HTTPS website to send the HTTPS response to your web browser?</li>
                                    <li>What is the size of the data in the HTTPS response packet sent from the HTTPS website to your browser?</li>
                                </ol><br/>
                            </ul>

                            <!-- :: Submit -->
                            <h5 style="margin-top: 20px;">Submission Instructions</h5>

                            Use Canvas to submit your homework. You need to make a single compressed file (<code>.tar.gz</code>) that contains your write-up as a PDF file. Your PDF write-up should contain the following things:<br/><br/>

                            <ul>
                                <li><b>Task I (5 pts)</b></li>
                                <ul>
                                    <li>Your answer to the 7 questions above.</li>
                                    <li>Your analysis: provide 2-3 sentences explaining why you see the results.</li>
                                </ul>

                                <li><b>Task II (10 pts)</b></li>
                                <ul>
                                    <li>Your answer to the 14 questions above.</li>
                                    <li>Your analysis: provide 2-3 sentences explaining why you see the results.</li>
                                </ul>
                            </ul><br/>

                        </div>
                    </div>
                </div>


                <!-- HW2 -->
                <div class="card">
                    <div class="card-header" id="headingTwo">
                        <button class="btn btn-link collapsed" 
                            type="button" 
                            style="color: black;"
                            data-toggle="collapse" 
                            data-target="#homework2" 
                            aria-expanded="true" 
                            aria-controls="homework2">
                            <h4>Homework 2: Buffer Overflow</h4>
                        </button>
                    </div>
              
                    <div id="homework2" 
                         class="collapse" 
                         aria-labelledby="headingTwo"
                         data-parent="#homeworkExample">
                        <div class="card-body">

                            <!-- :: Deadlines -->
                            <h5>Important Dates</h5>
                            <ul>
                                <li><b style="color: #D73F09;">Out: 04.16.2025 09:00 AM PT</b></li>
                                <li><b style="color: #D73F09;">Due: 04.28.2025 11:59 PM PT</b></li>
                            </ul>


                            <!-- :: Introduction -->
                            <h5 style="margin-top: 20px;">Homework Overview</h5>
                            <p>
                                The learning objectives of this homework are for students to gain hands-on experience with <code>buffer overflow</code> attacks. These attacks exploit a buffer overrun vulnerability in a program, causing it to bypass its usual execution sequence and instead jump to alternative code (typically launching a shell!). The attack overflows the vulnerable buffer to introduce the alternative code onto the stack and modifies the return address to point to that code.
                            </p>


                            <!-- :: Setup -->
                            <h5 style="margin-top: 20px;">Initial Setup</h5>
                            <p>
                                To begin, you are required to use a Linux machine with <code>sudo</code> privileges. You should not complete this homework on a shared server or any OSU computing clusters. If you perform a buffer overflow attack in these shared environments, you will be responsible for any consequences, and the instructor will not be liable. Note that you cannot run this on a Mac or Windows laptop. While these systems support command-line environments, they do not allow you to execute buffer overflow attacks. If you do not have a Linux machine, the instructor recommends creating a virtual machine using a commodity virtualization software, such as VMWare.<br/><br/>

                                "One way to bypass the configuration hassles is to set up your own server using a popular cloud provider, Amazon Web Services (AWS). To do this, sign up for AWS, go to the AWS Console, and select EC2. Then, launch an instance, choosing the operating system <code>Ubuntu 22.04</code> and the instance type <code>t2.micro</code> (which is eligible for the free tier). You will also need to configure an SSH key and a Security Group. Once completed, you can find the server's IP address in the console. Use that IP to log in to the cloud server via your terminal.

                                <pre><code>
                                    $ ssh -i "your-aws-key" ubuntu@"your-server-ip"
                                </code></pre>

                                To run the code provided by the instructor, you will need to install a few packages, as listed below. Note that you may need to install more packages. In such cases, you can easily search the error message shown in the terminal on Google and find the answers.

                                <pre><code>
                                    $ sudo apt install cmake gcc g++ gdb
                                    $ sudo apt install vim-enhanced
                                    $ sudo apt install python3
                                </code></pre>

                                Many countermeasures, such as ASLR, have been developed to address buffer overflow vulnerabilities. Circumventing these defenses is not as easy as it may seem, so we will disable them for this homework assignment. You can do so by following these steps:

                                <pre><code>
                                    $ sudo -i
                                    # sysctl -w kernel.randomize_va_space=0
                                    # exit      // exit the sudo; our assignment should be done in the user space.
                                </code></pre>

                                <b style="color: #D73F09;">[Important Note] Once you complete the homework, be sure to turn off and delete the cloud server to avoid being charged.</b>
                            </p>


                            <!-- :: Task I -->
                            <h5 style="margin-top: 20px;">Task I: Access the (In-)accessible</h5>

                            Create a makefile, <code>Makefile</code>:
                            
                            <pre><code>
                                $ vim Makefile
                                // paste the content below
                                CC=gcc
                                CFLAGS=-g -fno-stack-protector

                                all: bof.c
                                    $(CC) -m32 -o bof bof.c $(CFLAGS)
                            </code></pre>

                            Create a vulnerable file <code>bof.c</code>, as follows:

                            <pre><code>
                                #include "stdio.h"
                                #include "stdlib.h"
                                #include "string.h"
                                #include "unistd.h"
                                
                                char *trueflag = "cs578{trueflag}";
                                char *fakeflag = "cs578{fakeflag}";
                                
                                void
                                shell(void) {
                                    setregid(getegid(), getegid());
                                    system("/bin/bash");
                                }
                                
                                void
                                process_user_input(void) {
                                    char *flag;
                                    char buff[12];
                                    char data[128];
                                
                                    // set the fake flag
                                    flag = fakeflag;
                                
                                    // load the memory locations
                                    printf("Your flag address is at %p\n", trueflag);
                                    printf("Your fakeflag is at %p\n", fakeflag);
                                    printf("Address of shell is at %p\n", &shell);
                                    printf("Currently, the flag variable has the value %p\n", flag);
                                    fgets(data, sizeof(data), stdin);
                                
                                    // copy the content directly to the buffer
                                    strncpy(buff, data, strlen(data));
                                
                                    printf("Your input was: [%s]\n", buff);
                                    printf("Your flag address is at %p\n", flag);
                                    printf("Your flag is %s\n", flag);
                                }
                                
                                int
                                main(void) {
                                    setvbuf(stdin, NULL, _IONBF, 0);
                                    setvbuf(stdout, NULL, _IONBF, 0);
                                    process_user_input();
                                }
                            </code></pre>

                            <!-- (python3 -c 'print("A" * 14 + "\x00")') | ./bof -->
                            You can now compile the bof.c file by running the <code>make</code> command. Once compiled, you are ready to exploit the buffer overflow vulnerability. The code by default, will print out the flag <code>cs578{fakeflag}</code>. Your job is to exploit the buffer overflow and force it to print out <code>cs578{trueflag}</code>.

                            
                            <!-- :: Task II -->
                            <h5 style="margin-top: 20px;">Task II: Run Malicious Code</h5>

                            Now that you are familiar with buffer overflow exploitation, the instructor has prepared a fun task for you—running an arbitrary function that the program cannot execute normally. In this case, the function is the <code>bash shell</code>! (wait what?) Use the exact same program that the Instructor provided above and work hard to get a shell.<br/><br/>

                            <span style="color: #D73F09;">Tip: Python "print" may not work in some cases, e.g., it could add some termination characters like \x00. Please look for some other ways to write the address to the buffer. The instructor would not respond to any questions regarding this tip; it is the part of the homework assignment.</span>

                            <!-- :: Submit -->
                            <h5 style="margin-top: 20px;">Submission Instructions</h5>

                            Use Canvas to submit your homework. You need to make a single compressed file (<code>.tar.gz</code>. <code>.tar</code> or <code>.zip</code>) that contains your write-up as a PDF file. Your PDF write-up should contain the followings:<br/><br/>

                            <ul>
                                <li><b>Task I (6 pts)</b></li>
                                <ul>
                                    <li>You need to provide a screenshot of your terminal showing the command and its output.</li>
                                    <li>You also need to provide a detailed explanation of how you exploit the buffer overrun to obtain the <code>trueflag</code>.</li>
                                </ul>

                                <li><b>Task II (9 pts)</b></li>
                                <ul>
                                    <li>You need to provide a screenshot of your terminal showing the command and its output.</li>
                                    <li>You also need to provide a detailed explanation of how you exploit the buffer overrun to obtain the <code>bash shell</code>.</li>
                                </ul>
                            </ul><br/>

                        </div>
                    </div>
                </div>


                <!-- HW3 -->
                <div class="card">
                    <div class="card-header" id="headingThree">
                        <button class="btn btn-link collapsed" 
                            type="button" 
                            style="color: black;"
                            data-toggle="collapse" 
                            data-target="#homework3" 
                            aria-expanded="true" 
                            aria-controls="homework3">
                            <h4>Homework 3: Cache-based Side-channel Attacks</h4>
                        </button>
                    </div>
              
                    <div id="homework3" 
                         class="collapse show" 
                         aria-labelledby="headingThree"
                         data-parent="#homeworkExample">
                        <div class="card-body">

                            <!-- :: Deadlines -->
                            <h5>Important Dates</h5>
                            <ul>
                                <li><b style="color: #D73F09;">Out: 04.30.2025 09:00 AM PT</b></li>
                                <li><b style="color: #D73F09;">Due: 05.14.2025 11:59 PM PT</b></li>
                            </ul>


                            <!-- :: Introduction -->
                            <h5 style="margin-top: 20px;">Homework Overview</h5>
                            <p>
                                The learning objective of this homework is for students to gain first-hand experience with <code>timing side-channel attacks</code>. These attacks exploit shared resources, such as cache memory shared between processors, causing the time it takes to execute an algorithm to become data-dependent. For example, if one program accesses certain data and a subsequent attacker accesses the same data, the retrieval time will be faster. By tracing such timing differences, an attacker can weaken the confidentiality of security-critical operations, such as cryptographic operations.
                            </p>


                            <!-- :: Setup -->
                            <h5 style="margin-top: 20px;">Initial Setup</h5>
                            <p>
                                You are required to use a Linux machine with <code>sudo</code> privileges. Note that <code>sudo</code> access is only needed to install the necessary packages; you won't be required sudo (or root) privileges to conduct the attack itself. You should not run this homework on a shared server or any OSU computing clusters. If you perform the attacks in these shared environments, you will be responsible for any consequences, and the instructor will not be held liable.<br/><br/>
                                
                                It may be challenging to run this on a Mac or Windows laptop (Note that the instructor did not try this. If you use these machines, it will be your challenges!). If you do not have a Linux machine, the instructor recommends creating an <code>Ubuntu 22.04</code> virtual machine using a commodity virtualization software, such as VMWare.<br/><br/>
                                
                                One way to bypass the configuration hassles is to set up your own server using a popular cloud provider, Amazon Web Services (AWS). To do this, sign up for AWS, go to the AWS Console, and select EC2. Then, launch an instance, choosing the operating system <code>Ubuntu 22.04</code> and the instance type <code>t2.micro</code> (which is eligible for the free tier). You will also need to configure an SSH key and a Security Group. Once completed, you can find the server's IP address in the console. Use that IP to log in to the cloud server via your terminal.

                                <pre><code>
                                    $ ssh -i "your-aws-key" ubuntu@"your-server-ip"
                                </code></pre>

                                To run the code provided by the instructor, you will need to install a few packages, as listed below. Note that you may need to install more packages. In such cases, you can easily search the error message shown in the terminal on Google and find the answers.

                                <pre><code>
                                    $ sudo apt install cmake gcc g++ gdb
                                    $ sudo apt install vim-enhanced
                                    $ sudo apt install python3
                                    $ sudo apt-get install binutils-dev libdwarf-dev libelf-dev
                                </code></pre>

                                N0w we are ready to run a side-channel attack. The specific attack we will explore is <code>Flush+Reload</code>, a timing side-channel technique based on the L3 cache. More details about this attack can be found in the original research paper. This paper is included in our reading list, and I encourage you to read it to understand the core concepts behind the attack. Don't worry—you will not need to implement the attack from scratch. Instead, we will use an existing implementation provided by the research community: <a href="https://github.com/Secure-AI-Systems-Group/CS578-HW3" target="_blank">Mastik</a>. Please follow the instructions in the <code>README.md</code> file to install Mastik on your machine.

                                <b style="color: #D73F09;">[Important Note] Once you complete the homework, be sure to turn off and delete the cloud server to avoid being charged.</b>
                            </p>


                            <!-- :: Task I -->
                            <h5 style="margin-top: 20px;">Task I: Reconnaissance</h5>

                            In this task, you will learn how to gather information about the target system. This is a crucial step in any attack, as it allows you to understand the system's architecture and identify potential vulnerabilities. You will also learn how to measure the latency of memory accesses, which is essential for timing side-channel attacks. 



                            Before we begin, think – what is the first step when planning to attack a system? We first need to gather information about the system’s attributes. This rule applies to attacking software, hardware, and even in real-life on non-computing systems! For example, if you wanted to plan a bank robbery, you would first need to figure out the floorplan of the bank, the locations of safes and security cameras, etc. In this part of the lab, you will see a few practical approaches people use to gain detailed microarchitecture information of commodity hardware. You will further get familiar with some common techniques and instructions that we can use to measure execution latencies on processors, which will help you mount your attacks later on.

                            <!-- Part 1.1: Determining Machine Architecture
                            The simplest way to gather hardware information is to use existing public system interfaces and documentation. Here is a list of commands that can be used to determine machine architecture information on Linux.

                            lscpu: Provides information on the type of processor and some summary information about the architecture in the machine.
                            less /proc/cpuinfo: Provides detailed information about each logical processor in the machine. (Type q to exit.)
                            getconf -a | grep CACHE: Displays the system configuration related to the cache. This will provide detailed information about how the cache is structured. The numbers that are reported using this command use Bytes (B) as the unit.
                            In addition, WikiChip is a good source of information, as it provides information specific to each processor and architecture. You can find a detailed architecture description of our lab machines (Intel Cascade Lake processors) here, which additionally provides the raw latency value for accessing different levels of caches.

                            1-1 Discussion Question

                            Fill in the blanks in the following table using the information you gathered about the cache configuration of the lab machine. You should be able to directly obtain the information for the first 3 blank columns using commands above. You will need to derive the number of sets using what you have learned about set-associative caches in 6.1910[6.004]. Raw latency can be obtained from the WikiChip document. The line size of L1 data cache has been filled in for you.

                            Cache	Cache Line Size	Total Size	Number of Ways (Associativity)	Number of Sets	Raw Latency
                            L1-Data	64 Bytes	 	 	 	 
                            L2	 	 	 	 	 
                            L3	 	 	 	 	 
                            Part 1.2: Timing a Memory Access
                            The information you can get from public sources can be limited, as hardware companies would not like to disclose all of their proprietary design details to general users and potential competitors. An alternative way to gather information is to reverse engineer the processor by running some very carefully designed instruction sequences on the processor and observing their behaviors.

                            In this part, you will try to reverse engineer the latencies for accessing the cache hierarchy. Specifically, we would like to know how long it takes to access cache lines that are located in the (a) L1 data cache, (b) L2 cache, (c) L3 cache, and (d) the DRAM.

                            The Reverse Engineering Plan
                            To measure the L1 latency, we can perform a load operation on a target address to bring the corresponding cache line into the L1 data cache. Then, we measure the access latency by counting the cycles it takes to re-access the same target address using measure_one_block_access_time. We have provided this code for you, and you can compile the starter code using the command make, and then run it with make run.

                            Your task is to complete the main function in main.c to populate the three arrays dram_latency, l2_latency, and l3_latency. We suggest you start with measuring DRAM latency, since measuring DRAM latencies is the easiest. You can leverage the instruction clflush to place the target address to DRAM.

                            Measuring L2 and L3 latencies is slightly more complex. To measure the L2 latency, we need to place the target address in the L2 cache. However, simply accessing the target address will make the address reside in the L1 cache. Therefore, need to access other addresses to evict the target address from the L1 cache. Thus, you first need to access the line to bring it into L1, then create cache conflicts to evict it into L2. When it comes to measuring the L3 latency, you need to similarly create cache conflicts to evict the cache line from both the L1 cache and the L2 cache.

                            Helper Functions
                            Before you start, make sure you familiarize yourself with C syntax and several useful x86 instructions. Read the code in utility.h and understand the following functions.

                            rdtscp and rdtscp64: Read the current timestamp counter of the processor and return a 32-bit or 64-bit integer.
                            lfence: Perform a serializing operation. Ask the processor to first complete the memory loads before the lfence instruction, then start issuing memory loads after the lfence instruction. Other variants of fences exist, such as sfence and mfence.
                            measure_one_block_access_time: Measure the latency of performing one memory access to a given address.
                            clflush: Flush a given address from the cache, evict the line from the whole cache hierarchy so that later accesses to the address will load from DRAM.
                            print_results_plaintext and print_results_for_visualization: Print the collected latency data in different formats. The default Makefile compiles two binaries: main uses print_results_plaintext, while main-visual uses print_results_for_visualization.
                            Pointer Arithmetic

                            Pointer arithemetic operations, such as new_ptr = old_ptr + 1, means moving the pointer forward by one element. For different types of pointers whose element size is different, the actual bytes being moved can be very different. For example, given a uint8_t pointer, since each element is 1 byte, +1 means moving the pointer foward by 1 byte. However, +1 of a uint64_t pointer means moving the pointer forward by 8 bytes. We highly suggest to use uint8_t pointers to make your address calculation easier and avoid introducing addressing mistakes. Further details about common C/C++ constructs can be found in the C Programming Recitation.

                            Visualization Support
                            Microarchitectural side channels are notoriously noisy, and it is common to get inconsistent latency results from run to run. To combat noise, the most commonly used methodology is to repeat the experiments and plot the distribution of the observed latencies. We have provided two Python scripts to help you launch multiple measurements and visualize these measurements. To install python packages used in these two scripts, please run:

                            python3 -m pip install matplotlib tqdm

                            run.py: A python script that will generate 100 runs from the main-visual binary. It will create a folder (if one doesn’t already exist) called data, and it will store all the generated samples there in json format. The script will overwrite the folder if it already exists.
                            graph.py: A python script that will plot the histogram of the samples collected from run.py. It will read the JSON files from the folder data and generate a pdf file of the histogram in a folder called graph.
                            Expected Outcome
                            When grading we will not check the exact latency numbers generated by your code, since different implementations can yield different latency numbers. For example, it is unlikely that your L1 latency will match the L1 raw latency number from WikiChip. This is because our measurement involves extra latency introduced by the lfence instructions. Besides, other factors such as the frequency of the core and prefetch configurations of the cache can also affect the latency.

                            If you want to check whether you are on the right track, you should look for the following patterns in your visualized plot. We also include an example plot below.

                            There are distinct peaks for DRAM, L3, and L2 latency.
                            The L1 and L2 latency do not need to be distinguishable.
                            Reference distribution plot

                            A reference memory latency distribution plot

                            1-2 Exercise

                            Fill in the code in main.c to populate the arrays dram_latency, l2_latency, and l3_latency.

                            DO NOT take latency measurements while also printing. Instead, measure then print.

                            When debugging your code, it is tempting to write code like this, which we call “measuring while printing”.

                            for i in l1_cache:
                                # Observe some aspect of the cache state
                                val = time_access(cache line i)
                                # In the same measurement loop, print the observed value out!
                                printf("The cache took %d cycles", val)
                                # Now we go to the next interation and measure again

                            Do not do this! We are no longer in the regular world, we are in the microarchitectural world, where each assembly instruction counts!

                            What do we mean by this? Under the hood, a “simple” call to printf involves executing a huge number of instructions. When you call printf, you are going to go to the libc library, doing some string processing, and eventually making a system call into the kernel (so, the entire CPU performs a context switch, and does who knows what else). Think about how many cache lines this call to printf will need to read/write – printing anything is a destructive action to the state of the cache.

                            Instead, you should measure then print. We suggest structuring your code like this:

                            uint64_t measurements[NUM_THINGS_TO_MEASURE]
                            # Measure
                            for i in l1_cache:
                                measurements[i] = time_access(cache line i)
                            # Then, print :)
                            print(measurements)

                            Tips for Reliably Triggering Cache Evictions

                            The following tips may help you if you get stuck when you could not observe differences between the L2 and L3 cache latency. A common pitfall is not properly evicting the target address from the L1/L2 cache due to various reasons.

                            Cache Line Size != Integer Size: To begin with, you should be careful with the the mismatch of access granularities. The smallest operational unit in cache is the cache line, which is larger than the size of an integer. Accessing two integers that fall into the same line (more precisely, that fall within the same cache line size aligned region of memory) will result in a cache hit, and won’t cause an eviction. So make sure to use eviction addresses that do not map to the same cache line when attempting to evict.

                            Advanced Cache Replacement Policy: The cache replacement policy in modern processors is more advanced than the simple policies that we learned in class, and is often not completely known to us. It may intelligently decide to keep a target address in the cache, rather than evicting it. To combat the advanced replacement policy, we suggest accessing the eviction buffer multiple times.

                            Virtual to physical address translation: Intuitively, we would imagine that given a cache, if we have a buffer whose size matches the cache size, then accessing each element in the buffer allows us to fully occupy every slot in the cache. However, this may not always be the case, due to virtual to physical address translation. Note that on our machine, the cache mapping is a function of physical address, while the software uses virtual address.

                            Let’s consider a toy example where a 8KB directly-mapped cache which can hold two 4K pages. If we have a two-page-size buffer, after virtual address translation, we can end up with three posibilities: 1) the buffer covers the whole cache; 2) both pages map to the top half of the cache; and 3) both pages map to the bottom half of the cache.

                            In this case, how can we reliably evict data from a certain cache level without the control of the address translation procedure? The common trick is to just use a buffer that is bigger than the cache itself – between 1.5x or even 4x of the cache size. Even though the eviction might still not be guaranteed, its likelihood is high enough.

                            1-3 Discussion Question

                            After completing your code, generate the histogram pdf file and include it in the lab report.

                            1-4 Discussion Question

                            Based on the generated histogram, report two thresholds, one to distinguish between L2 and L3 latency and the other to distinguish between L3 and DRAM latency.

                            Submission and Grading
                            You will need to submit the code Part1-Timing/main.c to your assigned Github repository. Your code should be able to reproduce the histogram you submitted. You can determine whether your implementation is correct by check the description in expected outcome. Due to noise, we will run your code multiple times (5 times) and grade based on the best results. You should feel comfortable to submit your code as long as it can generate the expected results most of the time. -->




                            
                            <!-- :: Task II -->
                            <h5 style="margin-top: 20px;">Task II: Flush+Reload on Matrix Multiplication</h5>

                            <!-- Now that you become familiar with cache behaviors, the instructor has prepared a fun task for you—running an arbitrary function that the program cannot execute normally. In this case, the function is the <code>bash shell</code>! (wait what?) Use the exact same program that the Instructor provided above and work hard to get a shell.<br/><br/> -->


                            <b>Task II-1 (3 pts).</b> 
                            The first task is to measure the timing difference between accessing data from the L3 cache versus from main memory. To do this, run the sample demo provided in Mastik:
                            <span>demo/FR-threshold.c</span>. (1) Begin by opening this source file and, in your report, provide a line-by-line explanation of what each part of the code does. (2) Then compile the code using the provided Makefile and run the demo code. You can do:
                            
                            <pre><code>
                                Mastik $ make   // I am sure you already did this
                                Mastik $ cd demo
                                Mastik $ ./FR-threshold
                            </code></pre>
                            
                            Include the output of the demo code in your report. You should also explain line-by-line what each output means.<br/><br/>


                            <b>Task II-2 (3 pts).</b>
                            <!-- Now that you're familiar with the Flush+Reload attack, the instructor has prepared a fun and hands-on task: you'll use this side-channel technique to infer the dimensions of input matrices!<br/><br/> -->
                            
                            <!-- Please first do the following steps:<br/><br/>
                            <ul>
                                <li>Download the compressed file: <a href="" target="_blank">FR-matrix.zip</a>.</li>
                                <li>Unzip the file.</li>
                                <li>Move the FR-matrix.c file into the <code>demo</code> directory within Mastik.</li>
                                <li>Compile the code using the same <code>make</code> command you used earlier.</li>
                                <li>Run the attack and observe how it reveals matrix dimension information through side-channel behavior.</li>
                            </ul> -->

                            <!-- Note that both input matrices are two-dimensional, and their widths and heights are powers of two (i.e., 2<sup>x</sup> for some integer x).<br/><br/> -->


                            Some instructions ...



                            <!-- :: Task II -->
                            <h5 style="margin-top: 20px;">Task III: Flush+Reload on Your Program</h5>

                            <b>Task III-1 (3 pts).</b>



                            <b>Task III-2 (3 pts).</b>


                            <!-- :: Submit -->
                            <h5 style="margin-top: 20px;">Submission Instructions</h5>

                            Use Canvas to submit your homework. You need to make a single compressed file (<code>.tar.gz</code>. <code>.tar</code> or <code>.zip</code>) that contains your write-up as a PDF file. Your PDF write-up should contain the followings:<br/><br/>

                            <ul>
                                <li><b>Task I (6 pts)</b></li>
                                <ul>
                                    <li>You need to provide a screenshot of your terminal showing the command and its output.</li>
                                    <li>You also need to provide a detailed explanation of how you exploit the buffer overrun to obtain the <code>trueflag</code>.</li>
                                </ul>

                                <li><b>Task II (9 pts)</b></li>
                                <ul>
                                    <li>You need to provide a screenshot of your terminal showing the command and its output.</li>
                                    <li>You also need to provide a detailed explanation of how you exploit the buffer overrun to obtain the <code>bash shell</code>.</li>
                                </ul>
                            </ul><br/>


                        </div>
                    </div>
                </div>


                <!-- HW4 -->
                <div class="card">
                    <div class="card-header" id="headingFour">
                        <button class="btn btn-link" 
                            type="button" 
                            style="color: black;"
                            data-toggle="collapse" 
                            data-target="#homework4" 
                            aria-expanded="false" 
                            aria-controls="homework4">
                            <h4>Homework 4: Prompt-based Jailbreaking Attacks</h4>
                        </button>
                    </div>
              
                    <div id="homework4" 
                         class="collapse" 
                         aria-labelledby="headingFour"
                         data-parent="#homeworkExample">
                        <div class="card-body">

                            <!-- :: Deadlines -->
                            <h5>To be announced soon.</h5>

                        </div>
                    </div>
                </div>

            </div>

            <hr noshade="" size="1">


            <!-- Footer -->
            <footer class="footer">
                <div class="container text-center">
                  <span class="text-muted">© Sanghyun Hong: 2025-Present.</span>
                </div>
            </footer>

        </div>

        <!-- Optional Javascript -->
        <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

    </body>
</html>
